// программа, которая получает данные о нагрузке сервера и передаёт эти данные на хранение в БД PostgreSQL 15
// нагрузка сервера с учетом операционной системы 0,3-0,4 %

#include <stdio.h>
#include <stdlib.h> 
#include <string.h>
#include <wctype.h> 
#include <wchar.h> 
#include <time.h> 
/* #include <libpq-fe.h>   // есть /usr/include/postgresql/ */
#include <ctype.h>
#include <iso646.h>
#include <stdbool.h>
#include <uchar.h>  //  /usr/include/uchar.h
#include <locale.h>
#include <math.h>
#include <threads.h> 
#include <unistd.h> // для sleep() read()
#include <errno.h> // return EXIT_SUCCESS; 

#include <sys/types.h>
#include <sys/wait.h>

#include "глобальные_переменные.h" 
#include "main.h" 

#include "запросы_к_бд.h" 
#include "нагрузка_пк.h" 
#include "входные_данные.h" 
#include "ошибки_обработка.h" 
#include "системные_функции.h"
#include "файлы_действия.h"



 
 // ./demon_нагрузка_cpu -db test_si_2023 -schema db_log -table нагрузка_системы -host localhost -port 5434 -user postgres -psw 11111 -log_path /home/postgres/z_mmvb_temp/z_test.log -delay 3  -test 2
 

 
int main(int argc, char *argv[]) 
{
        // Глобальные переменные, которые активируются в main.c
    //char глоб_время_как_текст[50]=""; 
    //char глоб_логфайл_путь[СТРОКА_255]=""; 
    //int глоб_режим_тестов=0; 
    //struct ключи_запуска глоб_об_ключи_запуска;
    //struct нагрузка_оперсист глоб_об_нагрузка_оперсист; 
 
    int успех_работы_функции =0;
    bool продолжаем_главн_цикл =true;
    int спешим_на_сек; // насколько секунд локальное время (Москва +2/+3 часа) больше времени UTC (+0)
    time_t время_чистки_ram_кэша;
    
                
                
    
    // ======================= анализ ключей на входе ======================
    //
    if (argc < 9) // ошибка, нехватка ключей для запуска программы. Как минимум их 1+8
    {
        printf("\n\nПрограмма НЕ имеет нужного количества параметров на входе. "
                "Сейчас указан(о) %i параметр(ов).\n", argc);
        f_описание_ключей();
        return 0; // выход из программы
    }


    успех_работы_функции = f_разбор_ключей_из_входа(argc, argv);  
    if (успех_работы_функции != 0)
    {
        printf("\n\nПри разборе ключей на входе программы, возникла ошибка. Проверьте ключи еще раз.");
        f_описание_ключей();
        return 0; // выход из программы
    }
    
    strcpy(глоб_логфайл_путь, глоб_об_ключи_запуска.arws_логфайл_путь);   
    глоб_режим_тестов = глоб_об_ключи_запуска.тест_сообщ; 
    
    if (1== глоб_об_ключи_запуска.вывод_помощи)  
        {f_описание_ключей();}
    
    // =================================================================================     
    
    
    
    
    
    
    // ========= проверка на предмет работы с лог файлом (можно ли в него писать) и тестовые записи =======
    // 
    успех_работы_функции = f_логфайл_тест_записи(); // проверка записи в лог.журнал
    
    if (успех_работы_функции != 0)
    {
        printf("\n Лог файл по пути: '%s'  \n невозможно создать или использовать уже существующий.\n", глоб_логфайл_путь);
        printf("\n Принудительный выход из работы программы. \n");
        return -1; 
    }
    else
    {
        if (1 == глоб_режим_тестов)  
        {
             printf("\n Проверен путь для записи в журнал сообщений: \033[1m '%s' \033[22m \n"
                    " Проблем с его использованием нет. \n", глоб_логфайл_путь );
        }        
        long int размер_логжурнала = f_размер_логжурнала();
        char стр1[255]="";
        char стр2[128]="";
        strcpy(стр1, глоб_время_как_текст);
        sprintf(стр2, " До сообщения, Размер журнала был равен %li байт.", размер_логжурнала);
        strcat(стр1, стр2);     
        
        успех_работы_функции = f_логфайл_запись_сообщения(стр1);
    }
    // =================================================================================   
    

    
    
    
 
    
    //  ============ структура нагрузки ПК.  Создание и наполнение всех переменных для работы кода ===================
    //             
            // первоначальное наполнение структуры с данными. ЧАСТИЧНОЕ (не все переменные активизируются и будут иметь значения)
    успех_работы_функции = f_об_нагрузка_оперсист_нов_точка(); 
            
       // прописывает количество ядер (реальные+вирутальные)
    глоб_об_нагрузка_оперсист.всего_ядер = f_cpuinfo();     
        
        // блок первичного наполнения данными о процессоре и его загрузке
    глоб_об_нагрузка_оперсист.cpu_тики_нагрузок_старые = 0;
    глоб_об_нагрузка_оперсист.cpu_тики_всего_старые = 0;
    успех_работы_функции = f_нагрузка_пк(); // нагрузка на процессор
    
        
        //!!!! обновлять 1 раз в 1 минуту!!! не чаще. Первичное Наполнение данными по работе SSD диска
    успех_работы_функции = f_блок_нагрузки_ssd(); 
        
        // наполнение данными по температуре первого ядра процессора (самого горячего)
    успех_работы_функции = f_блок_температура_cpu(); 
    
        // Первичное Наполнение данными по работе с оперативной памятью
    успех_работы_функции = f_блок_использование_ram(); 
    
        sleep(1); // между запросами нагрузки должно быть не менее 1 секунды или ядро ОС может заблокировать эту программу
    
        // обнуление данных и окончательное присвоение ВСЕМ данным (с учетом отдельных запуском функций) стартовых/корректных значений. 
    успех_работы_функции = f_об_нагрузка_оперсист_нов_точка(); 

        sleep(1);
        
    успех_работы_функции = f_промежуточые_значения(); // ПОЛНОЦЕННЫЕ ПЕРВЫЕ промежуточные значение, которые расчитываются каждые 1-15 секунд
    sleep(1); 
    
    // =========================================================================================
    
    

    
    
    
    
    
    // этот блок окда выводит служебные сообщения в терминал (если активирован данный режим нужным ключом)
    // Просто тестовая запись, которая выводит частично текущую нагрузку ПК (просто для проверки, что замеры происходят успешно)
    if (1 == глоб_режим_тестов)
    {
        printf("\n RAM_free=%li Mb, ram_all=%li Mb\n", (long int) глоб_об_нагрузка_оперсист.ram_полность_свободна_кб /1024, (long int) глоб_об_нагрузка_оперсист.ram_всего_кб/1024);
        printf(" RAM_cached=%5.2lf%%, ram_available=%5.2lf%% \n", 100.0 * глоб_об_нагрузка_оперсист.ram_cached_now, 100.0 * глоб_об_нагрузка_оперсист.ram_available_now);
        printf(" Всего ядер = %i \n", глоб_об_нагрузка_оперсист.всего_ядер);
        printf(" Текущая температура процессора = %4.2lf \n", глоб_об_нагрузка_оперсист.cpu_t_now);
        printf(" SSD: ssd_read_block_old= %lli \t\t ssd_write_block_old=%lli \n", глоб_об_нагрузка_оперсист.ssd_read_block_old, глоб_об_нагрузка_оперсист.ssd_write_block_old);       
    }




    

    int интервал_обновл_сек = глоб_об_ключи_запуска.интервал_обновл_сек; 
    double дробные_секунды = 0.0001;
    time_t порог_60_сек; // long int;
    
        // полночть по гринвичу = 3 часа ночи по МСК, а нам нужно четко в 00-15 по МСК времени!
    спешим_на_сек = разница_сек_часовых_поясов();   
    время_чистки_ram_кэша =  (time(NULL) - time(NULL) % (24*3600)) + (time_t)(24*3600 + 15*60 - спешим_на_сек);

                
    
    while (true == продолжаем_главн_цикл)
    {  
        продолжаем_главн_цикл = true;
                
                
        // проверяем временную точку. Каждые 5 минут создаём новую точку для записи и записываем её в БД, 
        if (time(NULL) > (глоб_об_нагрузка_оперсист.время_начало +300))
        {
                // Наполнение данными по работе SSD диска. 
                // Там просто разница между начальным и конечными значениями.
            успех_работы_функции = f_блок_нагрузки_ssd(); 
            
                // записываем данные о нагрузке системы из объекта = об_нагрузка_оперсист в БД PostgreSQL. 4-е попытки!
            for (int i2=1; i2 <=4; i2++)
            {
                успех_работы_функции = f_блок_записи_вбд_нагрузок_пк();
                if (0 == успех_работы_функции)  // = успешно
                { 
                    break; 
                }
                else // ошибка
                {
                    if (1 == глоб_режим_тестов)
                    {
                        printf("Соединение с сервером НЕ УДАЛОСЬ !!!\n");
                        printf("Попытка записи № %i. Описание ошибки смотри в лог.файле.\n", i2);
                    }
                }
                
                f_пауза_вработе_программы(i2*i2, дробные_секунды);
            }
            
                // установка всех зависимых переменных в глобальной струткуре в начальное состояние для обработки данных (сброс предыдущих значений)
            успех_работы_функции = f_об_нагрузка_оперсист_нов_точка();
            
                // Новые замеры нагрузки ПК 
            успех_работы_функции = f_промежуточые_значения();  
            
            
            
            порог_60_сек = time(NULL) - (time(NULL) % 60); // + (time_t) 60; // слежующая записб не ранее чем через 1 минуту (а то две записи будет сразу в БД

                //  функция по паузе (устанавливаем требуемое плавающее значение!!!
            f_пауза_вработе_программы(интервал_обновл_сек, дробные_секунды);
            
            f_дата_время_текст_значение(); // обновление метки о текущем времени 
            
        } // конец по внесению новой точки (кратной 5 минутам) в БД PostgreSQL
        
        
        
        
        
            // [ Промежуточные замеры нагрузки ПК ]
        успех_работы_функции = f_промежуточые_значения();  
        
        //printf("t_min=%f   t_max=%f   t_midl=%f    t_now=%f \n", глоб_об_нагрузка_оперсист.cpu_t_min, глоб_об_нагрузка_оперсист.cpu_t_max, (глоб_об_нагрузка_оперсист.cpu_t_сумма/(0.001+глоб_об_нагрузка_оперсист.циклов) ), глоб_об_нагрузка_оперсист.cpu_t_now );


        // Обновляем данные по нагрузке ПК каждые 60 секунд в БД, 
        if (time(NULL) > порог_60_сек)
        {
                // Наполнение данными по работе SSD диска. 
            успех_работы_функции = f_блок_нагрузки_ssd(); 
            
                // записываем данные о нагрузке системы из объекта = об_нагрузка_оперсист в БД PostgreSQL. 4-е попытки!
            успех_работы_функции = f_блок_записи_вбд_нагрузок_пк();

                // будущая временная точка для обновления БД с данными о нагрузке ПК
            порог_60_сек = time(NULL) - (time(NULL) % 60) + (time_t) 60;
            
        }
        



        if (1 == глоб_режим_тестов)
        {
               // ТЕСТОВЫЙ РЕЖИМ. Выводить дублирующую информацию о нагрезке системы на экран монитора
            printf(" %s ", глоб_время_как_текст);
            printf("CPU MAX: %4.1f, CPU MIDLE: %4.1f, CPU_now: %4.1f \t Sum_cpu: %4.1f (%i)\n", глоб_об_нагрузка_оперсист.cpu_max,  
                    (глоб_об_нагрузка_оперсист.cpu_сумма/глоб_об_нагрузка_оперсист.циклов), глоб_об_нагрузка_оперсист.cpu_now,  
                    глоб_об_нагрузка_оперсист.cpu_сумма, глоб_об_нагрузка_оперсист.циклов); 
        }


            //  Пауза от 2 до 15 секунд
        f_пауза_вработе_программы(интервал_обновл_сек, дробные_секунды);
        
        f_дата_время_текст_значение(); // обновление метки о текущем времени 
        


        
        
        
        
        // в 00-15 очистка КЭША после работы днём! +  указание размера журнала!
        // в 7-45 очистка КЭША после ночных скачиваний данных
        if (time(NULL) > время_чистки_ram_кэша)
        {
            // ночная очистки RAM КЭША (после дневной работы) и занесения записи в журнал, чтобы видеть, что все работает. (время в 00:15)
            if ( (time(NULL) % 3600) > 900 and (time(NULL) % 3600) <1800 ) 
            {
                    
                спешим_на_сек = разница_сек_часовых_поясов();   
                время_чистки_ram_кэша =  (time(NULL) - time(NULL)%(24*3600)) + (time_t)(7*3600 + 45*60 - спешим_на_сек); // создаём следующую временную точку = 7-45
                
                    // запись в лог файд (контроль, что журнал ведётся)
                long int размер_логжурнала = f_размер_логжурнала();
                char стр1[255]="";
                char стр2[128]="";
                strcpy(стр1, глоб_время_как_текст);
                sprintf(стр2, " ПОЛНОЧЬ. До сообщения, размер журнала был равен %li байт.\n", размер_логжурнала);
                strcat(стр1, стр2);     
        
                f_логфайл_запись_сообщения(стр1);
                
                system("sync"); 
                sleep(2);
                
                char* запрос_system = "echo 3 > /proc/sys/vm/drop_caches";
                int res = system(запрос_system); // только от имени root
                if (WEXITSTATUS(res)) //  если не 0, то ошибка
                {
                    int номер_ошибки = WEXITSTATUS(res);
                    f_текст_ошибки_POSIX(запрос_system, номер_ошибки);
                    // printf("Ошибка при попытке выполнить команду SYSTEM(). Код ошибки: %i\n", номер_ошибки);
                }
                else // если = 0, то все отработало успешно!
                {
                    // printf("Команда успешно была выполнена\n");
                }
            }
                // Утренняя очистки RAM КЭША (после ночных загрузок данных и расчётов начальных точек входа). (время в 07:45)
            else if ( (time(NULL) % 3600) > 2400 ) 
            {
                    // будущая временная точка для обновления БД с данными о нагрузке ПК
                спешим_на_сек = разница_сек_часовых_поясов(); 
                время_чистки_ram_кэша =  (time(NULL) - time(NULL)%(24*3600)) + (time_t)(24*3600 + 15*60 - спешим_на_сек); // создаём следующую временную точку = 00:15 


                system("sync"); 
                sleep(2);
                
                char* запрос_system = "echo 3 > /proc/sys/vm/drop_caches";
                int res = system(запрос_system); // только от имени root
                if (WEXITSTATUS(res)) //  если не 0, то ошибка
                {
                    int номер_ошибки = WEXITSTATUS(res);
                    f_текст_ошибки_POSIX(запрос_system, номер_ошибки);
                    // printf("Ошибка при попытке выполнить команду SYSTEM(). Код ошибки: %i\n", номер_ошибки);
                }
                else // если = 0, то все отработало успешно!
                {
                    // printf("Команда успешно была выполнена\n");
                }

    
    
            }
        } // завершился цикл по очистке RAM КЭШ ПАМЯТИ
        
    } // while (true == продолжаем_главн_цикл)
    
    
    printf("Этого сообщения не должно быть! Но Программа по учету нагрузки ПК с записью в БД ЗАВЕРШЕНА. \n\n");

    return 0; 
}

