// смотри в папке с main.c инструкцию по офорлмению кода


// В документации объясняется:
// Какую задачу решает  каждый алгоритм
// Какие входные значения допустимы
// Что возвращает модуль\функция\программа
// Так же содержит инфу о гиперпараметрах.

// f_xxx() = функция
// ari_xxx = массив из целых чисел (обычно 64 битные)
// arui_xxx = массив из unsigned integer (из целых беззнаковых чисел, так же обычно 64 бита)
// ard_xxx = массив из double (дробных чисел) float не применяю, т.к память все равно занимают как double
// ars_xxx = строка символов (массив из char)
// arws_xxx = строка символов wchar (массив из широких символов char, типа русский текст и команды нужны для широких символов)
// arук_xxx = массив из указателей. В нём содержатся предложения переменной длины. 
// 
// об_xxx = Объект, класс, он же ООП -> структура чего либо
// ук_xxx = указатель, адрес в памяти ссылающийся на начало чего либа
// ук_ук_ххх (укук_xxx) = указатель на адрес в памяти, который ссылается на другой указатель = **массив_указателей_на_текст





#ifndef ГЛОБАЛЬНЫЕ_ПЕРЕМЕННЫЕ_H
#define ГЛОБАЛЬНЫЕ_ПЕРЕМЕННЫЕ_H

#define СТРОКА_63 63  
#define СТРОКА_255 255
  
#define Ф_Ж  "\033[1m" // начало вывода жирным текстом в терминале
#define Ф_КЖ "\033[22m" // сброс вывода жирным текстом в терминале


    // глобальная строка, куда кидается фремя в формате       2023.10.30 11:26:43, понедельник 
    extern char глоб_время_как_текст[50]; // значения назначаются ТОЛЬКО в main.c


    // глобальная переменная путь к журналу ошибок/действий оно же "arws_логфайл_путь" из структуры "ключи_запуска"
    extern char глоб_логфайл_путь[СТРОКА_255]; // значения назначаются ТОЛЬКО в main.c



    // глобальная переменная оно же "тест_сообщ" из структуры "ключи_запуска".
    // выводит многие сообщения в терминал. Для отслеживания работоспособности.
    // В боевом режиме почти ничего из тестового режима не выводится.
    extern int глоб_режим_тестов; // значения назначаются ТОЛЬКО в main.c
    
    
    
    // импорт файла конфигурации. Первичные настройки работы программы (нагрузка процессора, 
    // температура процессора, оперативная память, жесткий диск ...
    struct ключи_запуска { 
        char arws_db[СТРОКА_63];        // имя БД в Постгрес
        char arws_schema[СТРОКА_63];    // имя схемы в БД PostgreSQL            // wchar_t
        char arws_table[СТРОКА_63];     // имя таблицы
        char arws_host[СТРОКА_63];      // адрес в сети или localhost
        char порт_бд[СТРОКА_63];        // порт
        char arws_user[СТРОКА_63];      // имя пользователя, его учетное имя от которой делается доступ к БД PostgresSQL
        char arws_пароль[СТРОКА_63];    // пароль пользователя
        int интервал_обновл_сек;        // частота запросов нагрузки по ПК.
        int тест_сообщ;                 // если =1, то сообщение выводится/дублируются в терминале. Нужно при отладке или во время тестов.
        int вывод_помощи;               // выводит инструкцию по ключам (help справка)
        char arws_логфайл_путь[СТРОКА_255]; // путь, где расположен журнал ошибок и действий
    };
       
    extern struct ключи_запуска глоб_об_ключи_запуска;
    
    
    
    // структура нагрузки системы - значения, которые мы контролируем и передаём в БД
    struct нагрузка_оперсист { 
        int циклов;         // количество измеренных периодов
        
            // +++
        double cpu_сумма;   // сумма нагрузки в процентов за измеряемый период    
        double cpu_now;     // нагрузка процессора в момент замера (сейчас) в процентах
        double cpu_min;     // минимальная нагрузка процессора в текущем интервале времени (5 минут) в процентах
        double cpu_max;     // максимальная нагрузка процессора в текущем интервале времени (5 минут) в процентах
        unsigned long int cpu_тики_нагрузок_старые;
        unsigned long int cpu_тики_всего_старые;
        
            // +++
        long long int ram_всего_кб;   // 1) ВСЕГО RAM. размер в кб, это 100%. Нужен для связанных расчетов
        long long int ram_полность_свободна_кб; // 2) MemFree    размер в кб. Учитывается как точка на момент закрытия периода
                        // полностью свободна (даже не зарезервированна)Память, которая нигде не используется
                        
            // +++
            // потенциально доступной памяти - следить как влияет на этот показатель работа программы на Си
        double ram_available_now;       // 3)MemAvailable   размер в процентах на текущий момент. 
                                        // Доступна (в том числе кэши + буферы, резервированная).
                                        // сюда так же входит выделенная, но не используемая память от PostgreSQL 
        double ram_available_сумма;     // сумма всех замеров за период в процентах 
        double ram_available_min;   // в процентах 
        double ram_available_max;   // в процентах 
        
        
            // +++
            // ВСЕГО занято оперативной памяти - следить как влияет на этот показатель работа программы на Си
        long long int ram_used_кб;      // Занятая оперативная память (всего) размер в кб 
        double ram_used_now;    // Занятая оперативная память (всего) размер в процентах    // USED = Total - Free - Buffers - Cache
        double ram_used_сумма;  // сумма всех замеров за период в процентах 
        double ram_used_min;    // в процентах 
        double ram_used_max;    // в процентах 

        
        // +++
            // занято буфером памяти пока не знаю, как это будет все влиять
        long long int ram_buffers_кб;      // *4)Buffers  размер в кб.   
        double ram_buffers_now;     // *4)Buffers  размер в процентах.    буферы примерно 5-6%
        double ram_buffers_сумма;   // сумма всех замеров за период в процентах 
        double ram_buffers_min;      // в процентах 
        double ram_buffers_max;      // в процентах 
        
        
        // +++
            // Это важный показатель - размер оперативной памяти его остаток выделенный на работе PostgreSQL
            // чем меньше этот показатель в процентах, тем меньше оперативки осталось для работы в Посгрес
            // а если этот показатель постоянно держится на высоком уровне, то мы выделили слишком много опреативки Постгрес
        long long int ram_cached_кб;   //   5)Cached размер в кб  
        double ram_cached_now;      // *5)Cached размер в процентах  кэш то что зарезервированно программами, так PostgreSQL занимает 9 Гб, даже не работая!!!)
        double ram_cached_сумма;    // сумма всех замеров за период в процентах 
        double ram_cached_min;      // в процентах 
        double ram_cached_max;      // в процентах 
        // очитска КЭШ памяти команде от имени суперпользователя (base) root@honor-srv:/home/postgres# echo 3 > /proc/sys/vm/drop_caches
                // но она полностью отбираем КЭШ память у PostgreSQL 
                // и размер ПОЛНОСТЬЮ свободной памяти увеличился с 4 Гб до 12 Гб. В общем, бесполезная штука.
        
        
        // +++
            // работа с SWAP файлом сколько скинули и считали с диска в кб
            // вполне возможно, что этот блок переменных будет переписываться.
            // считается как сумма всех изменений за указанный период относительно предыдущего значений
            // Память, которая когда-то была выгружена, заменяется обратно, но все еще находится в файле подкачки 
            // (если нужна память, ее не нужно выгружать СНОВА, потому что она уже находится в файле подкачки. Это экономит ввод-вывод)
        long long int ram_swap_cached_now_кб;     // 6)SwapCached  в кб перенесено в Swap диск из оперативки на жеский диск и обратно. Текущий (актуаьный) разме
        long long int ram_swap_cached_предыдущий_кб; // в кб
        int swap_read_block;    // они есть в планах
        int swap_write_block;   // они есть в планах
        
            // 13) Unevictable  Память, выделенная для пользовательского пространства, которая не может быть освобождена
            // 14) Mlocked      Память, заблокированная с помощью    mlock()
        // long long int ram_swap_total_кб;    // *15) SwapTotal  в кб   общий размер СВОП памяти
        // long long int ram_swap_free_кб;     // *16) SwapFree   в кб   Свободная СВОП память
        
        
            // +++
        long long int ram_max_очередь_записи_надиск_кб;     // 19) Dirty       Память, ожидающей обратной записи на диск. Сохраняем макисмальное значение !!!
        long long int ram_max_активная_запись_надиск_кб;    // 20) WriteBack    Память, которая активно записывается обратно на диск. Сохраняем макисмальное значение !!!
            
            
        // +++ 
            // это так же важный блок - анализирует сколько программа на Си занимает оперативной памяти во время своей работы
            // то есть как много еще можно выделить ей память за счет КЭШ оперативной памяти от PostgreSQL или всего достаточно!
        long long int ram_anon_pages_кб;
        double ram_anon_pages_now;      // оперативка занятая пользовательскими программами, приложениями в последнем замере в процентах 
                                    // 21) AnonPages    Страницы пользовательского пространства (не файлы, а оперативка). 
                                    //    Чем больше открываешь программ, тем больше чисо в этом поле.
        double ram_anon_pages_сумма;    // сумма всех замеров за период в процентах 
        double ram_anon_pages_min;      // в процентах 
        double ram_anon_pages_max;      // в процентах                 
                                            
                                            
            // 23) Shmem        Общий размер памяти, используемой общей памятью (типа память занятая системой, ядром)
                            //  При болшом количестве открытых программ, это значение практически не меняется.
            // 40) AnonHugePages Таблица больших пользователских пространств. Чем больше открываешь файлов, тем больше здесь число


        // +++
        // !!!! здесь запись и считывание блоков с диска SSD
                // !!!! здесь запись и считывание блоков с диска SSD просто обновляется число сколько всего считано и записано блоков жесткого диска
        // вполне возможно, что обнолвять каждую секунду не имеет смысла
        long long int ssd_read_block_old;
        long long int ssd_read_block_new;
        long long int ssd_write_block_old;  
        long long int ssd_write_block_new;  
        
        
        // +++
            // блок работы определения температуры процессора
        double cpu_t_сумма;     // сумма используемой температуры в градусах цельсия за измеряемый период
        double cpu_t_now;       // последний замер температуры
        double cpu_t_min;       // минимальная температура за указанный период
        double cpu_t_max;       // максимальная температура за указанный период


        // +++
        // это вренмя начала блока измеренй. Кратный 5 минутам 300 секундам)
        time_t время_начало;    //=8bit,     printf("\nTIME=%li    ...   %lu\n", об_нагрузка_оперсист.время_начало, sizeof(time_t));
     
     
        // +++
        int всего_ядер;
    };
    
    extern struct нагрузка_оперсист глоб_об_нагрузка_оперсист;


#endif


