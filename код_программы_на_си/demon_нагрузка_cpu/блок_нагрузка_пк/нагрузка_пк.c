// Данный блок функций вычисляет нагрузку на ПК 
// замеры нагрузки системы ->>> процессора
// замеры RAM
// замеры SSD диска - чтениеб запись страниц за период в 5 минут
// замеры температуры процессора
// замеры SWOP файла (нехватки оперативной памяти - скидывание её на жесткий диск)

#include <ctype.h>
#include <fcntl.h>
#include <iso646.h>
#include <locale.h>
#include <math.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <time.h>
#include <uchar.h>  //  /usr/include/uchar.h
#include <unistd.h> // для sleep() read()
#include <wchar.h>
#include <fcntl.h> // open("/proc/stat", O_RDONLY))
#include <threads.h> 


#include "глобальные_переменные.h" 
#include "ошибки_обработка.h"

#define МАКС_ДЛИНА_СТРОКИ 256


 



// ВНИМАНИЕ !!!!! для моей задачи нужно использовать библиотеку EPOLL и синхронный ввод вывод для DEBIAN
// так же нужно сипользовать библиотеку ядра Дебина из разряда = timerfd (сайт man7.org)!   функц = timerfd_create
// которая ждет в фоновом режиме указанное время и выводит из сна нашу программу.
// Таким образом наш скрипт выводится из сна или по запросу через сокет
// или запросом из системы по истичении указанного таймаута (к примеру 4 секунды)



// временная структура, для переноса данных внутри данного блока кода. Эта структура является закрытой и во вне не передаётся
static struct temp_нагрузка_пк {
    long long int temp_ram_всего_кб;
    long long int temp_ram_available_кб;
    long long int temp_ram_free_кб;
    long long int temp_ram_buffer_кб;
    long long int temp_ram_cached_кб;
    long long int temp_ram_swap_cached_now_кб;
    long long int temp_ram_очередь_на_ssd_кб;       // 19) Dirty       Память, ожидающей обратной записи на диск 
    long long int temp_ram_запись_на_ssd_кб;        // 20) текущая запись на диск
    long long int temp_ram_anon_pages_кб;
} об_temp_нагрузка_пк;





// временная структура, для статистики по жесткому диску. Эта структура является закрытой и во вне не передаётся
static struct temp_ssd_диск {
    long long int temp_ssd_read_old;
    long long int temp_ssd_read_new;
    long long int temp_ssd_write_old;
    long long int temp_ssd_write_new;
} об_temp_статистика_ssd;








// программа определяем стколько ядер всего у процессора в системе
// всего (реальные + виртуальные)
int f_cpuinfo(void)
{
    FILE *информационный_файл;
    char параметр[256];
    char символы_2[256];
    char символы_3[256];
    int всего_ядер=6;

    if((информационный_файл = fopen("/proc/cpuinfo", "r")) == NULL)    
    {
        fprintf(stdout, " Не удаётся открыть файл информации о процессоре. \n");      
    } 
    else 
    { 
        for (int i=0; i<22; i++) 
        {
            fscanf(информационный_файл, "%127s%127s%127s%*[^\n]", параметр, символы_2, символы_3);
            //printf(" '%s' === '%s' ====='%s' \n", параметр, символы_2, символы_3);
                
            if (0==strcmp("siblings", параметр)) 
            {
                всего_ядер = atoi(символы_3);
                //printf(" 107) Всего ядер = %i \n", всего_ядер);
                return всего_ядер; 
            }
            else
            {
                //printf(" 112) Всего ядер = %i \n", всего_ядер);
            }
        }
    }
    fclose(информационный_файл);
    
    return всего_ядер; 
}
















// вычисляет общий размер оперативной памяти в системе. Один раз за время работы программы.
static void f_ram_наполнение(struct temp_нагрузка_пк* об_temp_нагрузка_пк)
{
    FILE *информационный_файл;
    char параметр[64];
    long long int большое_число = 0;

    //printf(" '143) Запустили анализ ПАМЯТИ \n");
    if((информационный_файл = fopen("/proc/meminfo", "r")) == NULL)    
    {
        fprintf(stdout, " Не удаётся открыть файл информации о процессоре. \n");      
    } 
    else 
    { 
        for (int i=0; i<50; i++) 
        {
            fscanf(информационный_файл, "%s%lld%*[^\n]", параметр, &большое_число);
            //printf(" '%s'==='%d' \n", параметр, большое_число);
            if (0==strcmp("MemTotal:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_всего_кб = большое_число;
            }
            else if (0==strcmp("MemAvailable:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_available_кб = большое_число;
            }
            else if (0==strcmp("MemFree:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_free_кб = большое_число;
            }
            else if (0==strcmp("Buffers:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_buffer_кб = большое_число;
            }
            else if (0==strcmp("Cached:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_cached_кб = большое_число;
            }
            else if (0==strcmp("SwapCached:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_swap_cached_now_кб = большое_число;
            }
            else if (0==strcmp("Dirty:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_очередь_на_ssd_кб = большое_число;
            }
            else if (0==strcmp("WriteBack:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_запись_на_ssd_кб = большое_число;
            }
            else if (0==strcmp("AnonPages:", параметр)) 
            {
                об_temp_нагрузка_пк->temp_ram_anon_pages_кб = большое_число;
            }

        }       
    }
    fclose(информационный_файл);   
    // printf("194) temp_ram_anon_pages_кб=%lli\n", об_temp_нагрузка_пк->temp_ram_anon_pages_кб);
    return;
}



// функция по наполнению объекта "нагрузка операционной системы" данными использованию перативной памяти
int f_блок_использование_ram(void)
{
        // наполнение static (локальной) временной структуры по оперативной памяти
    f_ram_наполнение(&об_temp_нагрузка_пк);     
    
    
    глоб_об_нагрузка_оперсист.ram_всего_кб = об_temp_нагрузка_пк.temp_ram_всего_кб;
    глоб_об_нагрузка_оперсист.ram_available_now = (double) об_temp_нагрузка_пк.temp_ram_available_кб / глоб_об_нагрузка_оперсист.ram_всего_кб;
        глоб_об_нагрузка_оперсист.ram_available_min = (глоб_об_нагрузка_оперсист.ram_available_min > глоб_об_нагрузка_оперсист.ram_available_now) ? глоб_об_нагрузка_оперсист.ram_available_now : глоб_об_нагрузка_оперсист.ram_available_min;
        глоб_об_нагрузка_оперсист.ram_available_max = (глоб_об_нагрузка_оперсист.ram_available_max < глоб_об_нагрузка_оперсист.ram_available_now) ? глоб_об_нагрузка_оперсист.ram_available_now : глоб_об_нагрузка_оперсист.ram_available_max;
   
    глоб_об_нагрузка_оперсист.ram_полность_свободна_кб = об_temp_нагрузка_пк.temp_ram_free_кб;
    глоб_об_нагрузка_оперсист.ram_buffers_кб = об_temp_нагрузка_пк.temp_ram_buffer_кб;
    глоб_об_нагрузка_оперсист.ram_cached_кб = об_temp_нагрузка_пк.temp_ram_cached_кб;
         
         // Занятая оперативная память (всего) размер в процентах    // USED = Total - Free - Buffers - Cache
    глоб_об_нагрузка_оперсист.ram_used_кб = (глоб_об_нагрузка_оперсист.ram_всего_кб - глоб_об_нагрузка_оперсист.ram_полность_свободна_кб - 
                        глоб_об_нагрузка_оперсист.ram_buffers_кб - глоб_об_нагрузка_оперсист.ram_cached_кб);
    глоб_об_нагрузка_оперсист.ram_used_now = (double) глоб_об_нагрузка_оперсист.ram_used_кб / глоб_об_нагрузка_оперсист.ram_всего_кб;
        глоб_об_нагрузка_оперсист.ram_used_min = (глоб_об_нагрузка_оперсист.ram_used_min > глоб_об_нагрузка_оперсист.ram_used_now) ? глоб_об_нагрузка_оперсист.ram_used_now : глоб_об_нагрузка_оперсист.ram_used_min;
        глоб_об_нагрузка_оперсист.ram_used_max = (глоб_об_нагрузка_оперсист.ram_used_max < глоб_об_нагрузка_оперсист.ram_used_now) ? глоб_об_нагрузка_оперсист.ram_used_now : глоб_об_нагрузка_оперсист.ram_used_max;
 
        // занято буфером памяти пока не знаю, как это будет все влиять
    глоб_об_нагрузка_оперсист.ram_buffers_now = (double) глоб_об_нагрузка_оперсист.ram_buffers_кб / глоб_об_нагрузка_оперсист.ram_всего_кб;
    глоб_об_нагрузка_оперсист.ram_buffers_min = (глоб_об_нагрузка_оперсист.ram_buffers_min > глоб_об_нагрузка_оперсист.ram_buffers_now) ? глоб_об_нагрузка_оперсист.ram_buffers_now :  глоб_об_нагрузка_оперсист.ram_buffers_min;
    глоб_об_нагрузка_оперсист.ram_buffers_max = (глоб_об_нагрузка_оперсист.ram_buffers_max < глоб_об_нагрузка_оперсист.ram_buffers_now) ? глоб_об_нагрузка_оперсист.ram_buffers_now :  глоб_об_нагрузка_оперсист.ram_buffers_max;
  
        // *5)Cached размер в процентахб  кэш то что зарезервированно программами, так PostgreSQL занимает 7.8 Гб, даже не работая!!!)
    глоб_об_нагрузка_оперсист.ram_cached_now = (double) глоб_об_нагрузка_оперсист.ram_cached_кб / глоб_об_нагрузка_оперсист.ram_всего_кб;
    глоб_об_нагрузка_оперсист.ram_cached_min = (глоб_об_нагрузка_оперсист.ram_cached_min > глоб_об_нагрузка_оперсист.ram_cached_now) ? глоб_об_нагрузка_оперсист.ram_cached_now :  глоб_об_нагрузка_оперсист.ram_cached_min;
    глоб_об_нагрузка_оперсист.ram_cached_max = (глоб_об_нагрузка_оперсист.ram_cached_max < глоб_об_нагрузка_оперсист.ram_cached_now) ? глоб_об_нагрузка_оперсист.ram_cached_now :  глоб_об_нагрузка_оперсист.ram_cached_max;


        // 6)SwapCached  в кб перенесено в Swap диск из оперативки на жеский диск и обратно)
    глоб_об_нагрузка_оперсист.ram_swap_cached_now_кб = об_temp_нагрузка_пк.temp_ram_swap_cached_now_кб;
    глоб_об_нагрузка_оперсист.ram_swap_cached_предыдущий_кб = об_temp_нагрузка_пк.temp_ram_swap_cached_now_кб;

    
        // запись из оперативки на диск
            // 19) Dirty       Память, ожидающей обратной записи на диск
    глоб_об_нагрузка_оперсист.ram_max_очередь_записи_надиск_кб = (глоб_об_нагрузка_оперсист.ram_max_очередь_записи_надиск_кб < об_temp_нагрузка_пк.temp_ram_очередь_на_ssd_кб) ? 
                 об_temp_нагрузка_пк.temp_ram_очередь_на_ssd_кб : глоб_об_нагрузка_оперсист.ram_max_очередь_записи_надиск_кб;  
            // 20) WriteBack    Память, которая активно записывается обратно на диск   
    глоб_об_нагрузка_оперсист.ram_max_активная_запись_надиск_кб = (глоб_об_нагрузка_оперсист.ram_max_активная_запись_надиск_кб < об_temp_нагрузка_пк.temp_ram_запись_на_ssd_кб) ? 
                об_temp_нагрузка_пк.temp_ram_запись_на_ssd_кб : глоб_об_нагрузка_оперсист.ram_max_активная_запись_надиск_кб;  
    
   
        // 21) AnonPages    Страницы пользовательского пространства (не файлы, а оперативка). Чем больше открываешь программ, тем больше чисо в этом поле.
        // это так же важный блок - анализирует сколько программа на Си занимает оперативной памяти во время своей работы
    глоб_об_нагрузка_оперсист.ram_anon_pages_кб = об_temp_нагрузка_пк.temp_ram_anon_pages_кб;
    глоб_об_нагрузка_оперсист.ram_anon_pages_now = (double) глоб_об_нагрузка_оперсист.ram_anon_pages_кб / глоб_об_нагрузка_оперсист.ram_всего_кб;    
    глоб_об_нагрузка_оперсист.ram_anon_pages_min = (глоб_об_нагрузка_оперсист.ram_anon_pages_min > глоб_об_нагрузка_оперсист.ram_anon_pages_now) ? глоб_об_нагрузка_оперсист.ram_anon_pages_now :  глоб_об_нагрузка_оперсист.ram_anon_pages_min;
    глоб_об_нагрузка_оперсист.ram_anon_pages_max = (глоб_об_нагрузка_оперсист.ram_anon_pages_max < глоб_об_нагрузка_оперсист.ram_anon_pages_now) ? глоб_об_нагрузка_оперсист.ram_anon_pages_now :  глоб_об_нагрузка_оперсист.ram_anon_pages_max;
    
    
    return 0;
}

        // программа определяем стколько памяти (оперативной и SWAP) у нас на ПК
        // всего, занято, свободно, в том числе занято SWAP памятью
        // используем proc/meminfo
        // *1) MemTotal     ВСЕГО RAM
        // *2)MemFree       полностью свободна (даже не зарезервированна)Память, которая нигде не используется
        // 3)MemAvailable   Доступна (в том числе кэши + буферы, резервированная)
        // *4)Buffers       буферы
        // *5)Cached        кэш то что зарезервированно программами, так PostgreSQL занимает 9 Гб, даже не работая!!!)
        // 6)SwapCached     перенесено в Swap диск из оперативки на жеский диск)
        // 13) Unevictable  Память, выделенная для пользовательского пространства, которая не может быть освобождена
        // 14) Mlocked      Память, заблокированная с помощью    mlock()
        // *15) SwapTotal   общий размер СВОП памяти
        // *16) SwapFree    Свободная СВОП память
        // 19) Dirty        Память, ожидающей обратной записи на диск
        // 20) WriteBack    Память, которая активно записывается обратно на диск
        // 21) AnonPages    Страницы пользовательского пространства (не файлы, а оперативка). 
        //                  Чем больше открываешь программ, тем больше чисо в этом поле.
        // 23) Shmem        Общий размер памяти, используемой общей памятью (типа память занятая системой, ядром)
        //                  При болшом количестве открытых программ, это значение практически не меняется.
        // 40) AnonHugePages Таблица больших пользователских пространств. Чем больше открываешь файлов, тем больше здесь число


     















// фнутренняя (скрытая) функция по определению температуры процессора по 1-му ядру (самое перове из всех)
static double f_температура_cpu(void)
{
    FILE *информационный_файл;
    long long int большое_число = 0;

        //printf(" '303) Запустили считывание температуры процессора \n");
    if ((информационный_файл = fopen("/sys/class/hwmon/hwmon0/temp1_input", "r")) == NULL)    
    {
        fprintf(stdout, " Не удаётся открыть файл информации о температуре процессоре. \n");      
    } 
    else 
    { 
        for (int i=0; i<5; i++) 
        {
            if (1==fscanf(информационный_файл, "%lld%*[^\n]", &большое_число))
            {
                //printf(" '%s'==='%d' \n", параметр, большое_число);
            fclose(информационный_файл);   
            return большое_число/1000.0;;
            }
        }       
    }
    fclose(информационный_файл);   
    return 70.0;
}



// функция по наполнению объекта "нагрузка операционной системы" данными по температуре первого ядра процессора (самого горячего)
int f_блок_температура_cpu(void)
{
        // блок работы определения температуры процессора
    глоб_об_нагрузка_оперсист.cpu_t_now = f_температура_cpu(); 

    глоб_об_нагрузка_оперсист.cpu_t_min = (глоб_об_нагрузка_оперсист.cpu_t_min > глоб_об_нагрузка_оперсист.cpu_t_now) ? 
                    глоб_об_нагрузка_оперсист.cpu_t_now : глоб_об_нагрузка_оперсист.cpu_t_min;
    глоб_об_нагрузка_оперсист.cpu_t_max = (глоб_об_нагрузка_оперсист.cpu_t_max < глоб_об_нагрузка_оперсист.cpu_t_now) ? 
                    глоб_об_нагрузка_оперсист.cpu_t_now : глоб_об_нагрузка_оперсист.cpu_t_max;
    
    
    return 0;
}















// Функция, которая считывает статистику по SSD/жесткому диску
static int f_нагрузка_ssd(struct temp_ssd_диск* об_temp_статистика_ssd)
{
    FILE *информационный_файл;
    int i1, i2;
    long long int arr_значения[17];
    char диск_имя[64];
    
        //printf(" '363) Запустили считывание температуры процессора \n");
    if ((информационный_файл = fopen("/proc/diskstats", "r")) == NULL)    
    {
        fprintf(stdout, " Не удаётся открыть файл информации о температуре процессоре. \n");      
    } 
    else 
    { 
        fscanf(информационный_файл, "%d %d %s %lli %lli %lli %lli %lli %lli %lli %lli %lli %lli %lli %lli %lli %lli %lli %lli %lli",
		   &i1, &i2, диск_имя,
           &arr_значения[0], &arr_значения[1], &arr_значения[2], &arr_значения[3], &arr_значения[4], 
           &arr_значения[5], &arr_значения[6], &arr_значения[7], &arr_значения[8], &arr_значения[9],
           &arr_значения[10], &arr_значения[11], &arr_значения[12], &arr_значения[13], &arr_значения[14],
           &arr_значения[15], &arr_значения[16]); 
            // arr_значения[2] = 3 элемент =  количество прочитанных секторов (длинное без знака).
            // arr_значения[6] = 7 элемент =  количество записанных секторов (длинное без знака).
            
        об_temp_статистика_ssd->temp_ssd_read_new = arr_значения[2];
        об_temp_статистика_ssd->temp_ssd_write_new = arr_значения[6];
        
        // printf(" '382) f_нагрузка_ssd %lli, %lli \n", об_temp_статистика_ssd->temp_ssd_read_new, об_temp_статистика_ssd->temp_ssd_write_new);
    } 
    fclose(информационный_файл);   
    return 70.0;
}



// функция по наполнению объекта "нагрузка операционной системы" данными по работе SSD диска
int f_блок_нагрузки_ssd(void)
{
        // !!!! здесь запись и считывание блоков с диска SSD
    f_нагрузка_ssd(&об_temp_статистика_ssd);    
    глоб_об_нагрузка_оперсист.ssd_read_block_new = об_temp_статистика_ssd.temp_ssd_read_new;
    глоб_об_нагрузка_оперсист.ssd_write_block_new = об_temp_статистика_ssd.temp_ssd_write_new; 
    
    return 0;
}

        /*  описание /proc/diskstats
        Каждый набор статистики применим только к указанному устройству; если вам нужна общесистемная статистика, вам придется найти все устройства и суммировать их все.
        Поле 1 — количество завершенных операций чтения (длинное значение без знака).
            Это общее количество успешно завершенных операций чтения.
        Поле 2 – количество объединенных операций чтения, поле 6 – количество объединенных операций записи (длинное значение без знака)
            Операции чтения и записи, расположенные рядом друг с другом, могут быть объединены для повышения эффективности. 
            Таким образом, два чтения 4 КБ могут стать одним чтением 8 КБ, прежде чем они будут окончательно переданы на диск, и поэтому они 
            будут учитываться (и помещаться в очередь) как только один ввод-вывод. Это поле позволяет узнать, как часто это делалось.
        Поле 3 — количество прочитанных секторов (длинное без знака).
            Это общее количество успешно прочитанных секторов.
        Поле 4 — количество миллисекунд, затраченных на чтение (беззнаковое целое число).
            Это общее количество миллисекунд, затраченное на все чтения (измеряемое от blk_mq_alloc_request() до __blk_mq_end_request()).
        Поле 5 — количество завершенных операций записи (длинное значение без знака).
            Это общее количество операций записи, выполненных успешно.
        Поле 6 — количество объединенных записей (длинное значение без знака).
            См. описание поля 2.
        Поле 7 — количество записанных секторов (длинное без знака).
            Это общее количество успешно записанных секторов.
        Поле 8 — количество миллисекунд, затраченных на запись (беззнаковое целое число).
            Это общее количество миллисекунд, затраченное на все записи (измеряемое от blk_mq_alloc_request() до __blk_mq_end_request()).
        Поле 9 – количество операций ввода-вывода, выполняющихся в данный момент (беззнаковое целое число).
            Единственное поле, которое должно стремиться к нулю. Увеличивается по мере передачи запросов в соответствующую структуру request_queue и 
            уменьшается по мере их завершения.
        Поле 10 — количество миллисекунд, затраченных на операции ввода-вывода (беззнаковое целое число).
            Это поле увеличивается до тех пор, пока поле 9 не равно нулю.
            Начиная с версии 5.0, это поле считает секунды, когда был запущен или завершен хотя бы один запрос. 
            Если запрос выполняется более двух секунд, то некоторое время ввода-вывода может не учитываться в случае одновременных запросов.
        Поле 11 – взвешенное количество миллисекунд, затраченных на операции ввода-вывода (беззнаковое целое число).
            Это поле увеличивается при каждом запуске ввода-вывода, завершении ввода-вывода, объединении ввода-вывода или 
            чтении этих статистических данных на количество выполняемых операций ввода-вывода (поле 9), умноженное на количество миллисекунд, 
            потраченных на ввод-вывод с момента последнее обновление этого поля. Это позволяет легко измерить как время завершения ввода-вывода, 
            так и накопившуюся невыполненную работу.
        Поле 12 — количество завершенных сбросов (длинное значение без знака)
            Это общее количество успешно выполненных сбросов.
        Поле 13 – количество объединенных сбросов (длинное значение без знака)
            См. описание поля 2.
        Поле 14 – количество отброшенных секторов (длинное значение без знака)
            Это общее количество успешно отброшенных секторов.
        Поле 15 — количество миллисекунд, затраченных на отбрасывание (целое число без знака).
            Это общее количество миллисекунд, потраченное на все сбросы (измеряемое от blk_mq_alloc_request() до __blk_mq_end_request()).
        Поле 16 – количество выполненных запросов на очистку.
            Это общее количество успешно выполненных запросов на очистку.
            Уровень блоков объединяет запросы на очистку и выполняется не более одного за раз. Это подсчитывает запросы на очистку, выполненные диском. 
            Не отслеживается по разделам.
        Поле 17 — количество миллисекунд, затраченных на промывку.
            Это общее количество миллисекунд, затраченное на все запросы на очистку.            */





















// первичное наполнение данными как только созданной структуры, т
// это создание новой точки для последующего анализа нагрузки ПК
// в ней идет наполнение значениями по умолчанию, а так же первичное наполнение/копирование блоков 
int f_об_нагрузка_оперсист_нов_точка(void)
{    
    
    // подробная информация о struct нагрузка_оперсист в файле глобальные_переменные.h
    глоб_об_нагрузка_оперсист.циклов=0;
        
        // обновление данных по процессору
    //глоб_об_нагрузка_оперсист.cpu_now = 0.0;       
    глоб_об_нагрузка_оперсист.cpu_сумма=0.0;
    глоб_об_нагрузка_оперсист.cpu_min = глоб_об_нагрузка_оперсист.cpu_now;
    глоб_об_нагрузка_оперсист.cpu_max = глоб_об_нагрузка_оперсист.cpu_now;
    
    
    // ram_всего_кб;   не обнуляем
    // ram_полность_свободна_кб; не обнуляем. Учитывается как точка на момент закрытия периода
    
    // double ram_available_now;     
    глоб_об_нагрузка_оперсист.ram_available_сумма = 0;     // сумма всех замеров за период в процентах 
    глоб_об_нагрузка_оперсист.ram_available_min = глоб_об_нагрузка_оперсист.ram_available_now;   
    глоб_об_нагрузка_оперсист.ram_available_max = глоб_об_нагрузка_оперсист.ram_available_now;   
    

    // double ram_used_now;     
    // long long int ram_used_кб;  
    глоб_об_нагрузка_оперсист.ram_used_сумма = 0;     // сумма всех замеров за период в процентах 
    глоб_об_нагрузка_оперсист.ram_used_min = глоб_об_нагрузка_оперсист.ram_used_now;   
    глоб_об_нагрузка_оперсист.ram_used_max = глоб_об_нагрузка_оперсист.ram_used_now;  


    // занято буфером памяти 
    // double ram_buffers_now;          // *4)Buffers  размер в процентах.    буферы примерно 5-6%   
    // long long int ram_buffers_кб;    // *4)Buffers  размер в кб.   
    глоб_об_нагрузка_оперсист.ram_buffers_сумма = 0;   // сумма всех замеров за период в процентах 
    глоб_об_нагрузка_оперсист.ram_buffers_min = глоб_об_нагрузка_оперсист.ram_buffers_now;      
    глоб_об_нагрузка_оперсист.ram_buffers_max = глоб_об_нагрузка_оперсист.ram_buffers_now;     
    
    
    // Это важный показатель - размер оперативной памяти, зарезервированный КЭШ участок и его остаток выделенный на работе PostgreSQL
    // double ram_cached_now;      // *5)Cached размер в процентах  кэш то что зарезервированно программами, так PostgreSQL занимает 9 Гб, даже не работая!!!)
    // long long int ram_cached_кб;   //   5)Cached размер в кб  
    глоб_об_нагрузка_оперсист.ram_cached_сумма = 0;    // сумма всех замеров за период в процентах 
    глоб_об_нагрузка_оперсист.ram_cached_min = глоб_об_нагрузка_оперсист.ram_cached_now;   
    глоб_об_нагрузка_оперсист.ram_cached_max = глоб_об_нагрузка_оперсист.ram_cached_now;   
    // очитска КЭШ памяти команде от имени суперпользователя (base) root@honor-srv:/home/postgres# echo 3 > /proc/sys/vm/drop_caches
            // но она полностью отбираем КЭШ память у PostgreSQL и размер ПОЛНОСТЬЮ свободной памяти увеличился с 4 Гб до 12 Гб. В общем, бесполезная штука.
    
    
     // работа с SWAP файлом сколько скинули и считали с диска в кб
    глоб_об_нагрузка_оперсист.ram_swap_cached_предыдущий_кб = глоб_об_нагрузка_оперсист.ram_swap_cached_now_кб;
    глоб_об_нагрузка_оперсист.swap_read_block=0;
    глоб_об_нагрузка_оперсист.swap_write_block=0;
    
    
    глоб_об_нагрузка_оперсист.ram_max_очередь_записи_надиск_кб = 0;     // 19) Dirty       Память, ожидающей обратной записи на диск. Сохраняем макисмальное значение !!!
    глоб_об_нагрузка_оперсист.ram_max_активная_запись_надиск_кб = 0;    // 20) WriteBack    Память, которая активно записывается обратно на диск. Сохраняем макисмальное значение !!!


    // это так же важный блок - анализирует сколько программа на Си занимает оперативной памяти во время своей работы
    // double ram_anon_pages_now;  
    // long long int ram_anon_pages_кб; 
    глоб_об_нагрузка_оперсист.ram_anon_pages_сумма = 0;    
    глоб_об_нагрузка_оперсист.ram_anon_pages_min = глоб_об_нагрузка_оперсист.ram_anon_pages_now;   
    глоб_об_нагрузка_оперсист.ram_anon_pages_max = глоб_об_нагрузка_оперсист.ram_anon_pages_now;   


        // !!!! здесь запись и считывание блоков с диска SSD
    глоб_об_нагрузка_оперсист.ssd_read_block_old = глоб_об_нагрузка_оперсист.ssd_read_block_new;
    глоб_об_нагрузка_оперсист.ssd_write_block_old = глоб_об_нагрузка_оперсист.ssd_write_block_new;

    
        // блок работы определения температуры процессора
    // double cpu_t_now;       // последний замер температуры
    глоб_об_нагрузка_оперсист.cpu_t_сумма=0.0;  // сумма используемой температуры в градусах цельсия за измеряемый период
    глоб_об_нагрузка_оперсист.cpu_t_min = глоб_об_нагрузка_оперсист.cpu_t_now;   
    глоб_об_нагрузка_оперсист.cpu_t_max = глоб_об_нагрузка_оперсист.cpu_t_now;       


    // начальная временная точка (чачало) кратная 5 минутам 
    глоб_об_нагрузка_оперсист.время_начало = time(NULL);
    глоб_об_нагрузка_оперсист.время_начало = глоб_об_нагрузка_оперсист.время_начало - (глоб_об_нагрузка_оперсист.время_начало % 300); 
    // printf("%li", глоб_об_нагрузка_оперсист.время_начало);
    
    return 0;
}





    
    
   





    
    
// функция по наполнению объекта "нагрузка операционной системы" данными
int f_нагрузка_пк(void)
{
    // более универсальный и более быстрый вариант
    int наш_файл;
    char массив_значений_кактекст[15][15];
    int n;
    char buff[100]; // BUFSIZ=16кб       char buff[BUFSIZ];  char buff[100]
    char ch;
    bool новый_блок = false;  

    unsigned long int cpu_тики_реж_пользоват = 0;
    unsigned long int cpu_тики_реж_польз_низк_приорит = 0;
    unsigned long int cpu_тики_режим_системы = 0;
    unsigned long int cpu_тики_режим_простоя = 0;
    
    unsigned long int cpu_тики_нагрузок_новые = 0;
    unsigned long int cpu_тики_всего_новые = 0;
    double cpu_нагрузка_проценты = 0.0; 
    
    unsigned long int cpu_тики_нагрузок_старые;
    unsigned long int cpu_тики_всего_старые;  

    cpu_тики_нагрузок_старые = глоб_об_нагрузка_оперсист.cpu_тики_нагрузок_старые;
    cpu_тики_всего_старые = глоб_об_нагрузка_оперсист.cpu_тики_всего_старые;


    if((наш_файл = open("/proc/stat", O_RDONLY)) == -1) // #include <fcntl.h>
    {
        fprintf(stdout, " Не удаётся открыть файл нагрузки процессора. \n");
        return 1; 
    } 
    
    
    // #include <unistd.h>
    n = read(наш_файл, buff, 100); // BUFSIZ = 16 кб, чуть дольше      read(наш_файл, buff, BUFSIZ)   

    int строка_изфайла = 1;
    int блок_из_строки = 1;
    int позиция_внутри_блока = 0;

    for(int j = 0; j < n; j++) 
    {
        if((ch = buff[j]) == '\n') 
        {
            строка_изфайла++;
            break;
        }
            
        // это общая нагрузка на процессор. записываем данные как текст в текстовой массив (массив указателей)
        if(строка_изфайла == 1) 
        {
            if(ch == ' ' or ch == '\t') 
            {
                новый_блок = true;
                позиция_внутри_блока = 0;
                continue;
            }
            
            // пришлось добавить, т.к два проблема или пробел и табуляция вызывали сбой в работе блок_из_строки
            if(новый_блок == true) 
            {
                блок_из_строки++;
                новый_блок = false;
            }
                
            // первая строка имеет вид cpu  3939633 440808 905738 434303093 450622 0 414898 0 0 0
            // нулевой элемент массива заполняется СЛОВОМ CPU 
            массив_значений_кактекст[блок_из_строки - 1][позиция_внутри_блока] = ch;
            массив_значений_кактекст[блок_из_строки - 1][позиция_внутри_блока + 1] = '\0';
            позиция_внутри_блока++;
        }
    }

    close(наш_файл);
        
    cpu_тики_реж_пользоват= atol(массив_значений_кактекст[1]);
    cpu_тики_реж_польз_низк_приорит =  atol(массив_значений_кактекст[2]);
    cpu_тики_режим_системы =  atol(массив_значений_кактекст[3]);
    cpu_тики_режим_простоя =  atol(массив_значений_кактекст[4]);
    
        // printf("649) %d, %d, %d, %d \n",cpu_тики_реж_пользоват, cpu_тики_реж_польз_низк_приорит, cpu_тики_режим_системы, cpu_тики_режим_простоя);

    cpu_тики_нагрузок_новые =cpu_тики_реж_пользоват + cpu_тики_реж_польз_низк_приорит + cpu_тики_режим_системы;
    cpu_тики_всего_новые = cpu_тики_нагрузок_новые + cpu_тики_режим_простоя;

    cpu_нагрузка_проценты = 100.0 * ((double)(cpu_тики_нагрузок_новые - cpu_тики_нагрузок_старые)) 
             / ((double)(cpu_тики_всего_новые - cpu_тики_всего_старые));
    
    
    глоб_об_нагрузка_оперсист.cpu_now = cpu_нагрузка_проценты;
    глоб_об_нагрузка_оперсист.cpu_min = (глоб_об_нагрузка_оперсист.cpu_min > cpu_нагрузка_проценты) ? cpu_нагрузка_проценты : глоб_об_нагрузка_оперсист.cpu_min ; 
    глоб_об_нагрузка_оперсист.cpu_max = (глоб_об_нагрузка_оперсист.cpu_max < cpu_нагрузка_проценты) ? cpu_нагрузка_проценты : глоб_об_нагрузка_оперсист.cpu_max ; 
    
    глоб_об_нагрузка_оперсист.cpu_тики_нагрузок_старые =  cpu_тики_нагрузок_новые;
    глоб_об_нагрузка_оперсист.cpu_тики_всего_старые = cpu_тики_всего_новые;
    
    return 0;
}










// функция по расчету промежуточных значений с интервалами от 1 до 15 секунд
// эти значения записываются в структуру с данными и при наступлении контрольных точек - скидываются в БД в таблицу
int f_промежуточые_значения(void)
{ 
    
    // !!!!! нагрузка процессора 
    f_нагрузка_пк();
    глоб_об_нагрузка_оперсист.cpu_сумма = глоб_об_нагрузка_оперсист.cpu_сумма + глоб_об_нагрузка_оперсист.cpu_now;
    
    // !!!!! оперативная память 
    f_блок_использование_ram();  
    глоб_об_нагрузка_оперсист.ram_available_сумма = глоб_об_нагрузка_оперсист.ram_available_сумма + глоб_об_нагрузка_оперсист.ram_available_now; // доступная память
    глоб_об_нагрузка_оперсист.ram_used_сумма = глоб_об_нагрузка_оперсист.ram_used_сумма + глоб_об_нагрузка_оперсист.ram_used_now;  // ВСЕГО занято оперативной памяти
    глоб_об_нагрузка_оперсист.ram_buffers_сумма = глоб_об_нагрузка_оперсист.ram_buffers_сумма + глоб_об_нагрузка_оперсист.ram_buffers_now;  // ВСЕГО буферизированная памяти
    глоб_об_нагрузка_оперсист.ram_cached_сумма = глоб_об_нагрузка_оперсист.ram_cached_сумма + глоб_об_нагрузка_оперсист.ram_cached_now;  // 5)Cached размер в процентах  кэш то что зарезервированно программами, так PostgreSQL занимает 9 Гб, даже не работая!!!)
    
    if (глоб_об_нагрузка_оперсист.ram_swap_cached_now_кб != глоб_об_нагрузка_оперсист.ram_swap_cached_предыдущий_кб) // SWAP файл. Из оперативки на диск и из диска в оперативку
    {
        if (глоб_об_нагрузка_оперсист.ram_swap_cached_now_кб < глоб_об_нагрузка_оперсист.ram_swap_cached_предыдущий_кб)
        {
            // считали из кэша назад в оперативку   = int swap_read_block;    // они есть в планах
            глоб_об_нагрузка_оперсист.swap_read_block = глоб_об_нагрузка_оперсист.swap_read_block + 
                        глоб_об_нагрузка_оперсист.ram_swap_cached_предыдущий_кб - глоб_об_нагрузка_оперсист.ram_swap_cached_now_кб;
        }
        else
        {
            // скинули из оперативки в кэш (размер кэша увеличился)  = int swap_write_block;   // они есть в планах
            глоб_об_нагрузка_оперсист.swap_write_block = глоб_об_нагрузка_оперсист.swap_write_block + 
                        (глоб_об_нагрузка_оперсист.ram_swap_cached_now_кб - глоб_об_нагрузка_оперсист.ram_swap_cached_предыдущий_кб);
        }
    }
    
    
    глоб_об_нагрузка_оперсист.ram_anon_pages_сумма = глоб_об_нагрузка_оперсист.ram_anon_pages_сумма + глоб_об_нагрузка_оперсист.ram_anon_pages_now; // 21) AnonPages    Страницы пользовательского пространства (не файлы, а оперативка). 
    

    // !!!!! нагрузка SSD диска
        // f_блок_нагрузки_ssd(об_нагрузка_оперсист);
        // !!!! здесь запись и считывание блоков с диска SSD просто обновляется число сколько всего считано и записано блоков жесткого диска
        // вполне возможно, что обнолвять каждую секунду не имеет смысла
    

    // функция по наполнению объекта "нагрузка операционной системы" данными по температуре первого ядра процессора (самого горячего)
    f_блок_температура_cpu();
    глоб_об_нагрузка_оперсист.cpu_t_сумма = глоб_об_нагрузка_оперсист.cpu_t_сумма + глоб_об_нагрузка_оперсист.cpu_t_now; // сумма используемой температуры в градусах цельсия за измеряемый период
    
    
    
    
    
    глоб_об_нагрузка_оперсист.циклов = глоб_об_нагрузка_оперсист.циклов+1;
    
    return 0;
}



